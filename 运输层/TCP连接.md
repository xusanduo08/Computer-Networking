* TCP是面向连接的，一个应用进程在像另一个进程发送数据之前，两个进程必须先相互“握手”。
* TCP连接提供的是__全双工服务__。
* TCP连接也总是__点对点__。
* 三次握手
  * 客户首先发送一个特殊的TCP报文段
  * 服务器用另一个特殊的TCP报文段来响应
  * 最后，客户再用第三个特殊报文段作为响应。
* 前两个报文段不承载有效载荷，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。由于在这两台主机之间发送了3个报文段，所以这种连接的简历过程常常称为__三次握手__。
* TCP报文段序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号因此是该报文段数据字段首字节的字节流编号。
* 假设主机A向主机B发送信息，主机A填充进报文段的确认好是主机A期望从主机B收到的下一字节的序号。
* 因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供__累积确认__。
* 一条TCP连接的双方均可随机地选择初始序号。
* 对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中，这种确认被认为是被__捎带__在服务器到客户的数据报文段中的。
* IP不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性。
* 每个报文段都包含一个序号，这个序号就是该报文段第一个数据字节的字节流编号。
* 如果定时器还没有为某些其他报文段而运行，则当报文段传给IP时，TCP就启动该定时器（将定时器想象成为与最早的未被确认的报文段相关联是有帮助的）。
* TCP通过重传引起超时的报文段来响应超时事件。
* TCP的状态变量SendBase是最早的未被确认的字节序号（因此SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号）。
* 一个ACK到达后，如果有未被确认的报文段，TCP还要重新启动定时器。
* 考虑主机A向主机B发送报文段的情况：主机A连续发送了两个报文段，第一个报文段序号是92，包含8字节数据；第二个报文段序号是100，包含20字节数据。假设两个报文段都完好无损的到达主机B，并且主机B为每一个报文段分别发送一个确认。第一个确认报文序号是100，第二个确认报文的确认号是120。现在假设在超时之前这两个报文段中没有一个确认报文到达主机A。当超时事件发生时，主机A重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段将不会重传。
* 每当超时事件发生时，TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍。
* 在从上层应用收到数据和收到ACK时重新启动定时器时，超时间隔都是由最近的EstimatedRTT值与DevRTT的值推算得到。
* 发送方通常可在超时事件发生之前通过注意所谓冗余ACK来较好的检测到丢包的情况。
* __冗余ACK__就是再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认。
* 当TCP接收方收到一个具有这样序号的报文段时，即其序号大于下一个所期望的、按序的报文段，它检测到了数据流中的一个间隔，这就是说有报文段丢失。这个间隔可能是由于在网络中报文段丢失或者重新排序造成的。因为TCP不使用否定确认，所以接收方不能向发送方发回一个显示的否定确认。相反，它只是对已经接收到的最后一个按序字节数据进行重复确认（产生一个冗余ACK）。

产生TCP ACK的建议：

| 事件                                  | TCP接收方动作                                 |
| ----------------------------------- | ---------------------------------------- |
| 具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认 | 延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK |
| 具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输     | 立即发送单个累计ACK，以确认两个按序                      |
| 比期望序号打的失序报文段到达。检测出间隔                | 立即发送冗余ACK，只是下一个期待字节的序号（其为间隔低端的序号）        |
| 能部分或完全填充接收数据间隔的报文段到达                | 倘若该报文段起始于间隔的低端，则立即发送ACK                  |

* 如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。
* 如果TCP发送方接收到对相同数据的3个冗余ACK，它把这当成一种指示，说明跟在这个已被确认3次的报文段之后的报文段已经丢失。
* 一旦收到3个冗余ACK，TCP就执行__快速重传__。
* TCP确认是__累积式__的，正确接收但失序的报文段是不会被接收方逐个确认的。
* TCP发送方仅需维持已发送过但未被确认的字节的最小序号（SendBase）和下一个要发送的字节的序号（NextSeqNum）。
* 许多TCP实现会将正确接收但失序的报文段缓存起来。
* TCP通过让发送方维护一个称为__接收窗口__的变量来提供流量控制。
* 接收窗口用于给发送方一个指示-----该接收方还有多少可用的缓存空间。
* LastByteSent - LastByteAcked <= rwnd
* 三次握手、四次握手
* SYN洪泛攻击